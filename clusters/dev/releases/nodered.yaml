apiVersion: apps/v1
kind: Deployment
metadata: { name: nodered, namespace: iot }
spec:
  replicas: 1
  selector: { matchLabels: { app: nodered } }
  template:
    metadata: { labels: { app: nodered } }
    spec:
      containers:
      - name: nodered
        image: nodered/node-red:3
        ports: [{ containerPort: 1880 }]
        env:
          - { name: TZ, value: "Europe/Rome" }
          - { name: INFLUX_URL, value: "http://influxdb2.observability.svc.cluster.local:8086" }
          - { name: INFLUX_ORG, value: "hassan" }
          - { name: INFLUX_BUCKET, value: "telemetry" }
          - { name: INFLUX_TOKEN, value: "CHANGE_ME_TOKEN" }
          - { name: WRITE_PRECISION, value: "s" }
        volumeMounts:
          - { name: data,  mountPath: /data }
          - { name: flows, mountPath: /data/flows.json, subPath: flows.json }
        readinessProbe:
          httpGet: { path: /, port: 1880 }
          initialDelaySeconds: 10
          periodSeconds: 10
      volumes:
        - name: data
          persistentVolumeClaim: { claimName: nodered-data }
        - name: flows
          configMap: { name: nodered-flows }
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata: { name: nodered-data, namespace: iot }
spec:
  accessModes: [ ReadWriteOnce ]
  resources: { requests: { storage: 1Gi } }
  storageClassName: local-path
---
apiVersion: v1
kind: Service
metadata: { name: nodered, namespace: iot }
spec:
  selector: { app: nodered }
  ports: [{ name: http, port: 1880, targetPort: 1880 }]
---
apiVersion: v1
kind: ConfigMap
metadata: { name: nodered-flows, namespace: iot }
data:
  flows.json: |
[
      {"id":"tab","type":"tab","label":"Pipeline"},
      {"id":"httpw","type":"http request","z":"tab","name":"Influx Write","method":"POST","ret":"txt","paytoqs":false,"url":"","tls":"","persist":false,"proxy":""}
      ,{"id":"mqtt_in_0","type":"mqtt in","z":"tab","name":"cpu_temp","topic":"sensors/temperature","qos":"1","datatype":"auto","broker":"b1","wires":[["parse_0"]]}
      ,{"id":"parse_0","type":"json","z":"tab","wires":[["shape_0","dbg_raw_0"]]}
      ,{"id":"shape_0","type":"function","z":"tab","name":"shape","func":"const m=msg.payload||{};const v=Number(m?.fields?.value ?? m.value ?? m.value ?? msg.payload);let ts=new Date();const raw=m.timestamp; if(raw!==undefined){const n=Number(raw); if(!isNaN(n)){ts=new Date(n<1e12?n*1000:n);} else {ts=new Date(raw);} } const tags=m.tags||{}; const meas='cpu_temp'; const tagPairs=[]; const include=["host", "unit", "zone"]; include.forEach(k=>{ if(tags[k]) tagPairs.push(`${k}=${String(tags[k]).replace(/[,= ]/g,'_')}`); }); const fields=[`value=${v}`]; const epoch=Math.floor(ts.getTime()/1000); msg.headers={ 'Authorization': 'Token '+env.get('INFLUX_TOKEN'), 'Content-Type':'text/plain; charset=utf-8'}; msg.url = `${env.get('INFLUX_URL')}/api/v2/write?org=${encodeURIComponent(env.get('INFLUX_ORG'))}&bucket=${encodeURIComponent(env.get('INFLUX_BUCKET'))}&precision=${env.get('WRITE_PRECISION')}`; msg.payload = `${meas}${tagPairs.length?','+tagPairs.join(','):''} ${fields.join(',')} ${epoch}`; return msg;","wires":[["httpw","dbg_shaped_0"]]}
      ,{"id":"dbg_raw_0","type":"debug","z":"tab","name":"RAW cpu_temp","active":true}
      ,{"id":"dbg_shaped_0","type":"debug","z":"tab","name":"SHAPED cpu_temp","active":true}
      ,{"id":"mqtt_in_1","type":"mqtt in","z":"tab","name":"hailo_temp","topic":"sensors/hailo/temp","qos":"1","datatype":"auto","broker":"b1","wires":[["parse_1"]]}
      ,{"id":"parse_1","type":"json","z":"tab","wires":[["shape_1","dbg_raw_1"]]}
      ,{"id":"shape_1","type":"function","z":"tab","name":"shape","func":"const m=msg.payload||{};const v=Number(m?.fields?.value ?? m.value ?? m.value ?? msg.payload);let ts=new Date();const raw=m.timestamp; if(raw!==undefined){const n=Number(raw); if(!isNaN(n)){ts=new Date(n<1e12?n*1000:n);} else {ts=new Date(raw);} } const tags=m.tags||{}; const meas='hailo_temp'; const tagPairs=[]; const include=["host", "unit", "zone"]; include.forEach(k=>{ if(tags[k]) tagPairs.push(`${k}=${String(tags[k]).replace(/[,= ]/g,'_')}`); }); const fields=[`value=${v}`]; const epoch=Math.floor(ts.getTime()/1000); msg.headers={ 'Authorization': 'Token '+env.get('INFLUX_TOKEN'), 'Content-Type':'text/plain; charset=utf-8'}; msg.url = `${env.get('INFLUX_URL')}/api/v2/write?org=${encodeURIComponent(env.get('INFLUX_ORG'))}&bucket=${encodeURIComponent(env.get('INFLUX_BUCKET'))}&precision=${env.get('WRITE_PRECISION')}`; msg.payload = `${meas}${tagPairs.length?','+tagPairs.join(','):''} ${fields.join(',')} ${epoch}`; return msg;","wires":[["httpw","dbg_shaped_1"]]}
      ,{"id":"dbg_raw_1","type":"debug","z":"tab","name":"RAW hailo_temp","active":true}
      ,{"id":"dbg_shaped_1","type":"debug","z":"tab","name":"SHAPED hailo_temp","active":true}
      ,{"id":"b1","type":"mqtt-broker","name":"Mosquitto","broker":"mosquitto.iot.svc.cluster.local","port":"1883"}
    ]
